
///// Generated Zig API /////
const std = @import("std");
const zalg = @import("zalgebra");
{% if not api.include_core -%}
const turing_api = @import("turing_api");
{%- endif %}

{% if api.include_core %}
//// Core Systems ////
pub fn enqueue_vec2(v: zalg.Vec2) u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    return 2;
}

pub fn enqueue_vec3(v: zalg.Vec3) u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    return 3;
}

pub fn enqueue_vec4(v: zalg.Vec4) u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    _host_f32_enqueue(v.w);
    return 4;
}

pub fn enqueue_quat(q: zalg.Quat) u32 {
    _host_f32_enqueue(q.x);
    _host_f32_enqueue(q.y);
    _host_f32_enqueue(q.z);
    _host_f32_enqueue(q.w);
    return 4;
}

pub fn enqueue_mat4(m: zalg.Mat4) u32 {
    enqueue_vec4(m.c0);
    enqueue_vec4(m.c1);
    enqueue_vec4(m.c2);
    enqueue_vec4(m.c3);
    return 16;
}


pub fn dequeue_vec2() zalg.Vec2 {
    return zalg.Vec2.init(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
    );
}

pub fn dequeue_vec3() zalg.Vec3 {
    return zalg.Vec3.init(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
    );
}

pub fn dequeue_vec4() zalg.Vec4 {
    return zalg.Vec4.init(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
    );
}

pub fn dequeue_quat() zalg.Quat {
    return zalg.Quat.init(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
    );
}

pub fn dequeue_mat4() zalg.Mat4 {
    return zalg.Mat4{
        .c0 = dequeue_vec4(),
        .c1 = dequeue_vec4(),
        .c2 = dequeue_vec4(),
        .c3 = dequeue_vec4(),
    };
}
{% endif %}{# api.include_core #}


//// Wasm Bindings ////
{% if api.include_core %}

extern "C" fn _host_strcpy(location: [*]u8, size: u32) void;
extern "C" fn _host_bufcpy(location: [*]u32, size: u32) void;
extern "C" fn _host_f32_enqueue(f: f32) void;
extern "C" fn _host_f32_dequeue() f32;
extern "C" fn _host_u32_enqueue(u: u32) void;
extern "C" fn _host_u32_dequeue() u32;

{% endif %}{# api.include_core #}

export fn _{{ api.name }}_semver() u64 {
    return ({{ api.semver.major }} << 32) | ({{ api.semver.minor }} << 16) | {{ api.semver.patch }};
}
pub const {{ api.name | case(style="upper_snake") }}_VERSION: []const u8 = "{{ api.version }}";

{%- macro ffi_params(func) -%}
{%- if func.static -%}
{%- for param in func.params -%}
{{ param.name | case(style="snake") }}: {{ param.type | ffi_type(map=types.zig) }}
{%- if not loop.last %}, {% endif -%}
{%- endfor -%}
{%- else -%}
handle: {{ func.class_name }}
{%- for param in func.params -%}
, {{ param.name | case(style="snake") }}: {{ param.type | ffi_type(map=types.zig) }}
{%- endfor -%}
{%- endif -%}
{%- endmacro ffi_params -%}

{%- macro ffi_funcs(funcs) -%}
{%- for func in funcs %}
extern "C" fn {{ func.wasm -}}
(
    {{- self::ffi_params(func=func) -}}
) {{ func.type | ffi_type(map=types.zig) }};
{%- endfor %}
{%- endmacro ffi_funcs -%}

{{- self::ffi_funcs(funcs=api.functions) }}
{%- for class in api.classes -%}
{{- self::ffi_funcs(funcs=class.functions) }}
{{- self::ffi_funcs(funcs=class.methods) }}
{%- endfor %}

{%- macro needs_allocator(func) -%}
{{ func | needs_alloc }}
{%- endmacro -%}

{%- macro zig_params(func) -%}
{%- if func.static -%}
{%- for param in func.params -%}
{{ param.name | case(style="snake") }}: {{ types.zig[param.type] }}
{%- if not loop.last %}, {% endif -%}
{%- endfor -%}
{%- if self::needs_allocator(func=func) %}{% if func.params %}, {% endif %}allocator: std.mem.Allocator{% endif -%}
{%- else -%}
self: *const {{ func.class_name }}
{%- for param in func.params -%}
, {{ param.name | case(style="snake") }}: {{ types.zig[param.type] }}
{%- endfor -%}
{%- if self::needs_allocator(func=func) %}, allocator: std.mem.Allocator{% endif -%}
{%- endif -%}
{%- endmacro zig_params -%}


{%- macro zig_return(func) -%}
{%- if self::needs_allocator(func=func) %}!{% endif -%}
{%- if func.type == "self" -%}
*const {{ func.class_name }}
{%- else -%}
{{ types.zig[func.type] }}
{%- endif -%}
{%- endmacro zig_return -%}


{%- macro converter(param, indent="") -%}
{%- if param.type == "&str" %}
{{ indent }}const turing_handle_{{ param.name | case(style="snake") }} = try allocator.dupeZ(u8, {{ param.name | case(style="snake") }});
{{ indent }}defer allocator.free(turing_handle_{{ param.name | case(style="snake") }});
{%- elif param.type == "&Vu32" %}
{{ indent }}{% if not api.include_core %}turing_api.{% endif %}_host_u32_enqueue(@intCast({{ param.name | case(style="snake") }}.len));
{%- elif param.is_glam_type %}
{{ indent }}const turing_handle_{{ param.name | case(style="snake") }} = {% if not api.include_core -%}
turing_api.{% endif %}enqueue_{{ param.type | case(style="lower") -}}
({{ param.name | case(style="snake") }});
{%- endif %}
{%- endmacro converter -%}


{%- macro convert_arg(param) -%}
    {%- if param.type == "&str" -%}
        turing_handle_{{ param.name | case(style="snake") }}.ptr
    {%- elif param.type == "&Vu32" -%}
        {{ param.name | case(style="snake") }}.ptr
    {%- elif param.is_glam_type -%}
        turing_handle_{{ param.name | case(style="snake") }}
    {%- else -%}
        {{ param.name | case(style="snake") }}
    {%- endif -%}
{%- endmacro convert_arg -%}


{%- macro convert_args(func) -%}
{%- if func.static -%}
{%- for param in func.params -%}
{{ self::convert_arg(param=param) }}
{%- if not loop.last %}, {% endif -%}
{%- endfor -%}
{%- else -%}
self
{%- for param in func.params -%}
, {{ self::convert_arg(param=param) }}
{%- endfor -%}
{%- endif -%}
{%- endmacro convert_args -%}


{%- macro func_inner(func, indent="") -%}
{%- for param in func.params -%}
{{- self::converter(param=param, indent=indent) }}
{%- endfor %}
{{ indent }}{% if func.unpack_return %}const turing_result = {% elif not func.skip_return %}return {% endif -%}
{{ func.wasm -}}
(
    {{- self::convert_args(func=func) -}}
);
{%- if func.type == "String" %}
{{ indent }}const turing_str = try allocator.alloc(u8, turing_result);
{{ indent }}{% if not api.include_core %}turing_api.{% endif %}_host_strcpy(turing_str.ptr, turing_result);
{{ indent }}return turing_str[0 .. turing_result - 1];
{%- elif func.type == "Vu32" %}
{{ indent }}const turing_buf = try allocator.alloc(u32, turing_result);
{{ indent }}{% if not api.include_core %}turing_api.{% endif %}_host_bufcpy(turing_buf.ptr, turing_result);
{{ indent }}return turing_buf;
{%- elif func.type == "self" %}
{{ indent }}return self;
{%- elif func.dequeue_return %}
{{ indent }}return {% if not api.include_core %}turing_api.{% endif %}dequeue_{{ func.type | case(style="lower") }}();
{%- endif -%}
{%- endmacro func_inner -%}



{%- macro func_impl(func, indent="") %}
{% if func.doc %}{{ indent }}{{ docs(doc=func.doc, d="/// ") }}{% endif %}
{{ indent }}pub fn {{ func.name | case(style="snake") -}}
(
    {{- self::zig_params(func=func) -}}
) {{ self::zig_return(func=func) }} {
    {{- self::func_inner(func=func, indent=indent ~ "    ") }}
{{ indent -}} }
{%- endmacro func_impl -%}


{%- macro func_impls(funcs, indent="") -%}
{%- for func in funcs -%}
{{- self::func_impl(func=func, indent=indent) }}
{%- endfor -%}
{%- endmacro func_impls -%}


{%- macro class_def(class) %}
{% if class.doc %}{{ docs(doc=class.doc, d="/// ") }}{% endif %}
pub const {{ class.name }} = struct {
    {% if not class.static %}opaqu: {{ types.zig["op*"] }},{% endif %}

{{- self::func_impls(funcs=class.functions, indent="    ") }}
{{- self::func_impls(funcs=class.methods, indent="    ") }}
};
{%- endmacro class_def %}

//// Functions ////
{{ self::func_impls(funcs=api.functions) }}


//// Classes ////
{%- for class in api.classes %}
{{- self::class_def(class=class) }}
{%- endfor %}















