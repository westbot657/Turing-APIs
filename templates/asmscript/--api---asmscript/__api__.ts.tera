

{%- macro opaque(type) %}{{ type | is_opaque }}{% endmacro -%}


{%- macro ffi_type(type) -%}
{%- if self::opaque(type=type) -%}
{{ types.asmscript["op*"] }}
{%- else -%}
{{ type | ffi_type(map=types.asmscript) }}
{%- endif -%}
{%- endmacro ffi_return -%}


{%- macro ffi_params(func) -%}
{%- if func.static -%}
{%- for param in func.params -%}
{{ param.name | case(style="snake") }}: {{ self::ffi_type(type=param.type) }}
{%- if not loop.last %}, {% endif -%}
{%- endfor -%}
{%- else -%}
handle: {{ types.asmscript["op*"] }}
{%- for param in func.params -%}
, {{ param.name | case(style="snake") }}: {{ self::ffi_type(type=param.type) }}
{%- endfor -%}
{%- endif -%}
{%- endmacro ffi_params -%}


{%- macro ffi_decls(funcs) -%}
{%- for func in funcs %}
@external("env", "{{ func.wasm }}")
declare function {{ func.wasm -}}
(
    {{- self::ffi_params(func=func) -}}
): {{ self::ffi_type(type=func.type) }};
{%- endfor -%}
{%- endmacro ffi_decls -%}


///// Generated AssemblyScript API /////
import { Vec2, Vec3, Vec4, Quat, Mat4 } from "../turing-api-asmscript/linear_algebra";
{% if not api.include_core %}
import * as Turing from "../../turing-api-asmscript/turing_api";
{% endif %}

//// Wasm Bindings ////
{% if api.include_core %}

@external("env", "_host_strcpy")
export declare function _host_strcpy(location: u32, size: u32): void;
@external("env", "_host_bufcpy")
export declare function _host_bufcpy(location: u32, size: u32): void;
@external("env", "_host_f32_enqueue")
export declare function _host_f32_enqueue(f: f32): void;
@external("env", "_host_f32_dequeue")
export declare function _host_f32_dequeue(): f32;
@external("env", "_host_u32_enqueue")
export declare function _host_u32_enqueue(f: u32): void;
@external("env", "_host_u32_dequeue")
export declare function _host_u32_dequeue(): u32;

{% endif -%}{# api.include_core #}

{{- self::ffi_decls(funcs=api.functions) }}
{%- for class in api.classes %}
{{- self::ffi_decls(funcs=class.functions) }}
{{- self::ffi_decls(funcs=class.methods) }}
{%- endfor %}

export function _{{ api.name }}_semver(): u64 {
    return ({{ api.semver.major }}u64 << 32) | ({{ api.semver.minor }}u64 << 16) | {{ api.semver.patch }}u64;
}

export const {{ api.name | case(style="upper_snake") }}_VERSION = "{{ api.version }}";

{% if api.include_core %}
//// Linear Algebra Helpers ////

export function __enqueue_vec2(v: Vec2): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    return 2;
}

export function __dequeue_vec2(): Vec2 {
    return new Vec2(
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

export function __enqueue_vec3(v: Vec3): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    return 3;
}

export function __dequeue_vec3(): Vec3 {
    return new Vec3(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

export function __enqueue_vec4(v: Vec4): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    _host_f32_enqueue(v.w);
    return 4;
}

export function __dequeue_vec4(): Vec4 {
    return new Vec4(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

export function __enqueue_quat(q: Quat): u32 {
    _host_f32_enqueue(q.x);
    _host_f32_enqueue(q.y);
    _host_f32_enqueue(q.z);
    _host_f32_enqueue(q.w);
    return 4;
}

export function __dequeue_quat(): Quat {
    return new Quat(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

export function __enqueue_mat4(m: Mat4): u32 {
    for (let i: i32 = 0; i < 16; i++) {
        _host_f32_enqueue(m.m[i]);
    }
    return 16;
}

export function __dequeue_mat4(): Mat4 {
    let out = new Mat4();
    for (let i: i32 = 0; i < 16; i++) {
        out.m[i] = _host_f32_dequeue();
    }
    return out;
}
{% endif %}{# api.include_core #}



{%- macro converter(param, indent="") -%}
{%- if param.type == "&str" %}
{{ indent }}let turing_handle_{{ param.name | case(style="snake") }} = String.UTF8.encode({{ param.name | case(style="snake") }}, true);
{%- elif param.type == "&Vu32" %}
{{ indent }}{% if not api.include_core %}Turing.{% endif %}_host_u32_enqueue(u32({{ param.name | case(style="snake") }}.length));
{{ indent }}let turing_view_{{ param.name | case(style="snake") }} = Uint32Array.wrap({{ param.name | case(style="snake") }});
{{ indent }}let turing_handle_{{ param.name | case(style="snake") }} = turing_view_{{ param.name | case(style="snake") }}.dataStart;
{%- elif param.is_glam_type %}
{{ indent }}let turing_handle_{{ param.name | case(style="snake") }} = {% if not api.include_core -%}
    Turing.{% endif %}__enqueue_{{ param.type | case(style="lower") }}({{ param.name | case(style="snake") }});
{%- endif -%}
{%- endmacro converter -%}


{%- macro asm_params(func) -%}
{%- for param in func.params -%}
{{ param.name | case(style="snake") }}: {{ types.asmscript[param.type] }}
{%- if not loop.last %}, {% endif -%}
{%- endfor -%}
{%- endmacro asm_params -%}


{%- macro convert_arg(param) -%}
{%- if param.type == "&str" or param.type == "&Vu32" or param.is_glam_type -%}
turing_handle_{{ param.name | case(style="snake") }}
{%- elif self::opaque(type=param.type) -%}
{{ param.name | case(style="snake") }}.handle
{%- else -%}
{{ param.name | case(style="snake") }}
{%- endif -%}
{%- endmacro convert_arg -%}


{%- macro convert_args(func) -%}
{%- if func.static -%}
{%- for param in func.params -%}
{{ self::convert_arg(param=param) }}
{%- if not loop.last %}, {% endif -%}
{%- endfor -%}
{%- else -%}
this.handle
{%- for param in func.params -%}
, {{ self::convert_arg(param=param) }}
{%- endfor -%}
{%- endif -%}
{%- endmacro convert_args -%}


{%- macro func_inner(func, indent="") -%}
{%- for param in func.params %}
{{- self::converter(param=param, indent=indent) }}
{%- endfor %}
{{ indent }}{% if func.unpack_return or self::opaque(type=func.type) %}let turing_result = {% elif not func.skip_return %}return {% endif -%}
{{- func.wasm -}}
(
    {{- self::convert_args(func=func) -}}
);
{%- if func.type == "String" %}
{{ indent }}let turing_str = heap.alloc(usize(turing_result));
{{ indent }}{% if not api.include_core %}Turing.{% endif %}_host_strcpy(u32(turing_str), turing_result);
{{ indent }}let turing_output = String.UTF8.decode(turing_str, true);
{{ indent }}heap.free(turing_str);
{{ indent }}return turing_output;
{%- elif func.type == "Vu32" %}
{{ indent }}let turing_buf = heap.alloc(usize(turing_result) * sizeof<u32>());
{{ indent }}{% if not api.include_core %}Turing.{% endif %}_host_bufcpy(u32(turing_buf), turing_result);
{{ indent }}let view = Uint32Array.wrap(turing_buf, turing_result);
{{ indent }}let arr = Array.from(view);
{{ indent }}heap.free(turing_buf);
{{ indent }}return arr;
{%- elif func.type == "self" %}
{{ indent }}return this;
{%- elif func.dequeue_return %}
{{ indent }}return {% if not api.include_core %}Turing.{% endif %}__dequeue_{{ func.type | case(style="lower") }}();
{%- elif self::opaque(type=func.type) %}
{{ indent }}return new {{ func.type | case(style="pascal") }}(turing_result);
{%- endif -%}
{%- endmacro func_inner -%}


{%- macro func_impls(funcs, indent="") -%}
{%- for func in funcs %}
{% if func.doc %}{{ indent }}{{ docs(doc=func.doc, d="/// ") }}{% endif %}
{% if not func.class_name -%}
export function {% else -%}
{{ indent }}public {% if func.static %}static {% endif %}
{%- endif %}{{ func.name | case(style="snake") -}}
(
    {{- self::asm_params(func=func) -}}
): {% if func.type == "self" %}{{ func.class_name }}
{%- else %}{{ types.asmscript[func.type] }}{% endif %} {
    {{- self::func_inner(func=func, indent=indent ~ "    ") }}
{{ indent -}} }

{%- endfor -%}
{%- endmacro func_impls %}



//// Functions ////
{{ self::func_impls(funcs=api.functions) }}

//// Classes ////
{%- for class in api.classes %}
{% if class.doc %}{{ docs(doc=class.doc, d="/// ") }}{% endif %}
@final {#- @final disables sub-classing #}
export class {{ class.name }} {
    {% if not class.static %}
    handle: {{ types.asmscript["op*"] }};

    constructor(handle: {{ types.asmscript["op*"] }}) {
        this.handle = handle;
    }
    {% endif %}
{{ self::func_impls(funcs=class.functions, indent="    ") }}
{{ self::func_impls(funcs=class.methods, indent="    ") }}
}

{%- endfor %}



