


///// Generated AssemblyScript API /////
import { Vec2, Vec3, Vec4, Quat, Mat4 } from "../turing-api-asmscript/linear_algebra";
{% if not api.include_core %}
import * as Turing from "../../turing-api-asmscript/turing_api";
{% endif %}

//// Wasm Bindings ////
{% if api.include_core %}

@external("env", "_host_strcpy")
export declare function _host_strcpy(location: u32, size: u32): void;
@external("env", "_host_bufcpy")
export declare function _host_bufcpy(location: u32, size: u32): void;
@external("env", "_host_f32_enqueue")
export declare function _host_f32_enqueue(f: f32): void;
@external("env", "_host_f32_dequeue")
export declare function _host_f32_dequeue(): f32;
@external("env", "_host_u32_enqueue")
export declare function _host_u32_enqueue(f: u32): void;
@external("env", "_host_u32_dequeue")
export declare function _host_u32_dequeue(): u32;

{% endif %}{# api.include_core #}

export function _{{ api.name }}_semver(): u64 {
    return ({{ api.semver.major }}u64 << 32) | ({{ api.semver.minor }}u64 << 16) | {{ api.semver.patch }}u64;
}

export const {{ api.name | case(style="upper_snake") }}_VERSION = "{{ api.version }}";

{% if api.include_core %}


//// Linear Algebra Helpers ////

function enqueue_vec2(v: Vec2): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    return 2;
}

function dequeue_vec2(): Vec2 {
    return new Vec2(
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

function enqueue_vec3(v: Vec3): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    return 3;
}

function dequeue_vec3(): Vec3 {
    return new Vec3(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

function enqueue_vec4(v: Vec4): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    _host_f32_enqueue(v.w);
    return 4;
}

function dequeue_vec4(): Vec4 {
    return new Vec4(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

function enqueue_quat(q: Quat): u32 {
    _host_f32_enqueue(q.x);
    _host_f32_enqueue(q.y);
    _host_f32_enqueue(q.z);
    _host_f32_enqueue(q.w);
    return 4;
}

function dequeue_quat(): Quat {
    return new Quat(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

function enqueue_mat4(m: Mat4): u32 {
    for (let i: i32 = 0; i < 16; i++) {
        _host_f32_enqueue(m.m[i]);
    }
    return 16;
}

function dequeue_mat4(): Mat4 {
    let out = new Mat4();
    for (let i: i32 = 0; i < 16; i++) {
        out.m[i] = _host_f32_dequeue();
    }
    return out;
}

{% endif %}{# api.include_core #}

{% macro func_impls(funcs) %}
{% endmacro func_impls %}

//// Functions ////
{{ self::func_impls(funcs=api.functions) }}

//// Classes ////
{%- for class in api.classes %}
{% if class.doc %}{{ docs(doc=class.doc, d="/// ") }}{% endif %}
@final {#- @final disables sub-classing #}
@unmanaged {#- @unmanaged makes the compiler turn this into a C struct #}
class {{ class.name | case(style="pascal") }} {
    {% if not class.static %}
    opaqu: {{ types.asmscript["op*"] }}
    {% endif %}
}

{%- endfor %}



