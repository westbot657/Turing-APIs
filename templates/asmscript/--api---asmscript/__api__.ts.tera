
{% macro c_arg(type) -%}
{%- if type == "&str" %}u32{% else %}{{ types.asmscript[type] }}{% endif -%}
{%- endmacro -%}

{%- macro c_params(params, is_method=false, class=false) -%}
{%- if is_method -%}
opaqu: {% if class.is_opaque %}{{ types.rs["op*"] }}{% else %}{{ class.name | case(style="pascal") }}{% endif %}
{%- for param in params -%}
, {{ param.name | case(style="snake") }}: {{ self::c_arg(type=param.type) }}
{%- endfor -%}
{%- else -%}
{%- for param in params -%}
{{ param.name | case(style="snake") }}: {{ self::c_arg(type=param.type) }}
{%- if not loop.last %}, {% endif -%}
{%- endfor -%}
{%- endif -%}
{%- endmacro -%}

{%- macro c_ret(type) -%}
{%- if type == "String" %}u32{% else %}{{ types.asmscript[type] }}{% endif %}
{%- endmacro -%}

{%- macro ffi_funcs(funcs, is_method=false, class=false) -%}
{%- for func in funcs %}
@external("env", "{{ func.from }}")
declare function {{ func.from }}({{ self::c_params(params=func.params, is_method=is_method, class=class) }}): {{ self::c_ret(type=func.type) }};
{%- endfor -%}
{%- endmacro -%}

{%- macro converter(param, indent="") -%}
    {%- if param.type == "&str" %}
    {{ indent }}let turing_handle_{{ param.name | case(style="snake") }} = String.UTF8.encode({{ param.name | case(style="snake") }}, true);
    {%- elif param.type in api.glam_types %}
    {{ indent }}let turing_handle_{{ param.name | case(style="snake") }} = enqueue_{{ param.type | case(style="lower") }}({{ param.name | case(style="snake") }});
    {%- endif -%}
{%- endmacro -%}

{%- macro convert_arg(param) -%}
{%- if param.type == "&str" or param.type in api.glam_types -%}
turing_handle_
{%- endif -%}
{{- param.name | case(style="snake") -}}
{%- endmacro -%}

{%- macro asm_params(params, is_method=false, class=false) -%}
    {%- for param in params -%}
    {{ param.name | case(style="snake") }}: {{ types.asmscript[param.type] }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
{%- endmacro -%}

{%- macro convert_args(params, is_method=false, class=false) -%}
    {%- if is_method -%}
        this{% if class.is_opaque %}.opaqu{% endif %}
        {%- for param in params -%}
        , {{ self::convert_arg(param=param) }}
        {%- endfor -%}
    {%- else -%}
        {%- for param in params -%}
        {{ self::convert_arg(param=param) }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro func_impl(func, is_method=false, class=false, indent="") -%}
    {%- for param in func.params -%}
    {{- self::converter(param=param, indent=indent) -}}
    {%- endfor %}
    {{ indent }}{%- if func.type == "String" or func.type in api.opaque_classes -%}let turing_result = {% elif func.type in api.glam_types %}{% elif func.type != "void" and func.type != "self" %}return {% endif -%}
    {{ func.from }}(
        {{- self::convert_args(params=func.params, is_method=is_method, class=class) -}}
    );{% if func.type == "self" %}
    {{ indent }}return this;
    {%- elif func.type == "String" %}
    {{ indent }}let turing_str = heap.alloc(usize(turing_result));
    {{ indent }}_host_strcpy(u32(turing_str), turing_result);
    {{ indent }}let turing_output = String.UTF8.decode(turing_str, true);
    {{ indent }}heap.free(turing_str);
    {{ indent }}return turing_output;
    {%- elif func.type in api.glam_types %}
    {{ indent }}return dequeue_{{ func.type | case(style="lower") }}();
    {%- elif func.type in api.opaque_classes %}
    {{ indent }}return new {{ func.type | case(style="pascal") }}(turing_result);
    {%- endif %}

{%- endmacro -%}

{%- macro func_impls(funcs, is_method=false, class=false, indent="", is_top=false) -%}
{%- for func in funcs %}
{% if func.doc %}{{ indent }}{{ docs(doc=func.doc, d="/// ") }}{% endif %}
{% if is_top -%}
export function {% else -%}
{{ indent }}public {% if not is_method %}static {% endif %}
{%- endif %}{{ func.name | case(style="snake") }}(
    {{- self::asm_params(params=func.params, is_method=is_method, class=class) -}}
): {% if func.type == "self" %}{{ class.name | case(style="pascal") }}{% else %}{{ types.asmscript[func.type] }}{% endif %} {
{{- self::func_impl(func=func, is_method=is_method, class=class, indent=indent) }}
{{ indent -}} }
{%- endfor %}
{%- endmacro -%}

///// Generated AssemblyScript API /////
import { Vec2, Vec3, Vec4, Quat, Mat4 } from "./linear_algebra";

//// Wasm Bindings ////
{% if api.name == "turing_api" %}@external("env", "_host_strcpy")
declare function _host_strcpy(location: u32, size: u32): void;
@external("env", "_host_f32_enqueue")
declare function _host_f32_enqueue(f: {{ types.asmscript["f32"] }}): void;
@external("env", "_host_f32_dequeue")
declare function _host_f32_dequeue(): {{ types.asmscript["f32"] }};{% endif %}
{{ self::ffi_funcs(funcs=api.functions) }}
{% for class in api.classes -%}
{{ self::ffi_funcs(funcs=class.functions, class=class) }}
{{ self::ffi_funcs(funcs=class.methods, is_method=true, class=class) }}
{%- endfor -%}

export function _{{ api.name }}_semver(): u64 {
    return ({{ api.semver.major }}u64 << 32) | ({{ api.semver.minor }}u64 << 16) | {{ api.semver.patch }}u64;
}

//// Linear Algebra Helpers ////

// Vec2
function enqueue_vec2(v: Vec2): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    return 2;
}

function dequeue_vec2(): Vec2 {
    return new Vec2(
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

// Vec3
function enqueue_vec3(v: Vec3): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    return 3;
}

function dequeue_vec3(): Vec3 {
    return new Vec3(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

// Vec4
function enqueue_vec4(v: Vec4): u32 {
    _host_f32_enqueue(v.x);
    _host_f32_enqueue(v.y);
    _host_f32_enqueue(v.z);
    _host_f32_enqueue(v.w);
    return 4;
}

function dequeue_vec4(): Vec4 {
    return new Vec4(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

// Quat
function enqueue_quat(q: Quat): u32 {
    _host_f32_enqueue(q.x);
    _host_f32_enqueue(q.y);
    _host_f32_enqueue(q.z);
    _host_f32_enqueue(q.w);
    return 4;
}

function dequeue_quat(): Quat {
    return new Quat(
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue(),
        _host_f32_dequeue()
    );
}

// Mat4 (column-major)
function enqueue_mat4(m: Mat4): u32 {
    for (let i: i32 = 0; i < 16; i++) {
        _host_f32_enqueue(m.m[i]);
    }
    return 16;
}

function dequeue_mat4(): Mat4 {
    let out = new Mat4();
    for (let i: i32 = 0; i < 16; i++) {
        out.m[i] = _host_f32_dequeue();
    }
    return out;
}

//// Functions ////
{{ self::func_impls(funcs=api.functions, is_top=true) }}


//// Classes ////
{%- for class in api.classes %}
{% if class.doc %}{{ docs(doc=class.doc, d="/// ") }}{% endif %}
class {{ class.name | case(style="pascal") }} {
    {%- for var in class.variables %}
    {{ var.name }}: {{ types.asmscript[var.type] }};
    {%- endfor %}
    {% if class.is_opaque -%}
    constructor(opaqu: {{ types.asmscript["op*"] }}) {
        this.opaqu = opaqu;
    }
    {%- endif %}
{{ self::func_impls(funcs=class.functions, class=class, indent="    ") }}
{{ self::func_impls(funcs=class.methods, is_method=true, class=class, indent="    ") }}
}

{%- endfor %}

