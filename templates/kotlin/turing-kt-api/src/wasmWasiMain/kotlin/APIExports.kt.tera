@file:OptIn(
    kotlin.wasm.ExperimentalWasmInterop::class,
)
@file:Suppress("Unused")

// Generated Kotlin API

import kotlinx.cinterop.*
import kotlin.native.concurrent.*

// host helper to copy string bytes from host memory into guest buffer
@WasmImport("turing_api", "_host_strcpy")
external fun _host_strcpy(location: CPointer<ByteVar>?, size: Int)

// FFI imports for global functions
{% for func in api.functions %}
@WasmImport("turing_api", "{{ func.from }}")
external fun {{ func.from }}({% for param in func.params %}{{ param.name | case(style="camel") }}: {% if param.type == "&str" or param.type == "String" %}CPointer<ByteVar>?{% else %}{{ types.kotlin[param.type] }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}){% if func.type == "void" %}{% elif func.type == "String" %}: CPointer<ByteVar>?{% else %}: {{ types.kotlin[func.type] }}{% endif %}
{% endfor %}

// FFI imports for classes
{% for class in api.classes -%}
{% for func in class.functions -%}
@WasmImport("turing_api", "{{ func.from }}")
external fun {{ func.from }}({% for param in func.params %}{{ param.name | case(style="camel") }}: {% if param.type == "&str" or param.type == "String" %}CPointer<ByteVar>?{% else %}{{ types.kotlin[param.type] }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}){% if func.type == "void" %}{% elif func.type == "String" %}: CPointer<ByteVar>?{% else %}: {{ types.kotlin[func.type] }}{% endif %}
{%- endfor -%}
{% for func in class.methods -%}
@WasmImport("turing_api", "{{ func.from }}")
external fun {{ func.from }}({% if class.is_opaque %}opaqu: Int{% else %}self: {{ class.name | case(style="pascal") }}{% endif %}{% for param in func.params %}, {{ param.name | case(style="camel") }}: {% if param.type == "&str" or param.type == "String" %}CPointer<ByteVar>?{% else %}{{ types.kotlin[param.type] }}{% endif %}{% endfor %}){% if func.type == "void" %}{% elif func.type == "String" %}: CPointer<ByteVar>?{% else %}: {{ types.kotlin[func.type] }}{% endif %}
{%- endfor -%}
{%- endfor %}

//// Functions ////
{% for func in api.functions %}
fun {{ func.name | case(style="camel") }}({% for param in func.params %}{{ param.name | case(style="camel") }}: {{ types.kotlin[param.type] }}{% if not loop.last %}, {% endif %}{% endfor %}){% if func.type != "void" %} : {{ types.kotlin[func.type] }}{% endif %} {
    val hostResult = {{ func.from }}({% for param in func.params %}{% if param.type == "&str" or param.type == "String" %}{{ param.name | case(style="camel") }}.cstr{% else %}{{ param.name | case(style="camel") }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
    {% if func.type == "String" -%}
    val useMe = hostResult?.toKString() ?: error("null pointer returned")
    useMe
    {% elif (api.opaque_classes is defined) and (func.type in api.opaque_classes) -%}
    {{ func.type | case(style="pascal") }}(opaqu = hostResult)
    {% elif func.type != "void" -%}
    hostResult
    {%- endif %}
}
{% endfor %}

//// Classes ////
{% for class in api.classes -%}
data class {{ class.name | case(style="pascal") }}(val opaqu: Int)

object {{ class.name | case(style="pascal") }}Api {
    {% for func in class.functions %}
    fun {{ func.name | case(style="camel") }}({% for param in func.params %}{{ param.name | case(style="camel") }}: {{ types.kotlin[param.type] }}{% if not loop.last %}, {% endif %}{% endfor %}){% if func.type != "void" %} : {{ types.kotlin[func.type] }}{% endif %} {
        val hostResult = {{ func.from }}({% for param in func.params %}{% if param.type == "&str" %}{{ param.name | case(style="camel") }}.cstr{% else %}{{ param.name | case(style="camel") }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
        {% if func.type == "String" -%}
        val useMe = hostResult?.toKString() ?: error("null pointer returned")
        useMe
        {% elif (api.opaque_classes is defined) and (func.type in api.opaque_classes) -%}
        {{ func.type | case(style="pascal") }}(opaqu = hostResult)
        {% elif func.type != "void" -%}
        hostResult
        {%- endif %}
    }
    {% endfor -%}

    {% for func in class.methods %}
    fun {{ func.name | case(style="camel") }}({% if class.is_opaque %}opaqu: Int{% else %}self: {{ class.name | case(style="pascal") }}{% endif %}{% for param in func.params %}, {{ param.name | case(style="camel") }}: {{ types.kotlin[param.type] }}{% endfor %}){% if func.type != "void" %} : {{ types.kotlin[func.type] }}{% endif %} {
        val hostResult = {{ func.from }}({% if class.is_opaque %}opaqu{% else %}self{% endif %}{% for param in func.params %}, {% if param.type == "&str" or param.type == "String" %}{{ param.name | case(style="camel") }}.cstr{% else %}{{ param.name | case(style="camel") }}{% endif %}{% endfor %})
        {% if func.type == "String" -%}
        val useMe = hostResult?.toKString() ?: error("null pointer returned")
        useMe
        {% elif (api.opaque_classes is defined) and (func.type in api.opaque_classes) -%}
        {{ func.type | case(style="pascal") }}(opaqu = hostResult)
        {% elif func.type != "void" -%}
        hostResult
        {%- endif %}
    }
    {% endfor %}
}
{% endfor %}

