

{% macro convert_arg(param) -%}
    {{ param.name | case(style="snake") }}
{%- endmacro -%}

{%- macro cpp_params(params, is_method=false) -%}
    {%- if is_method -%}
    {%- for param in params -%}
    {{ types.cpp[param.type] }} {{ param.name | case(style="snake") }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
    {%- else -%}
    {%- for param in params -%}
    {{ types.cpp[param.type] }} {{ param.name | case(style = "snake") }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro convert_args(params, is_method=false, class=false) -%}
    {%- if is_method -%}
        {% if class.is_opaque %}this->opaqu{% else %}this{% endif %}
        {%- for param in params -%}
        , {% if types.cpp[param.type] == "std::string" %}{{ self::convert_arg(param=param) }}.c_str(){% else %}{{ self::convert_arg(param=param) }}{% endif %}
        {%- endfor -%}
    {%- else -%}
        {%- for param in params -%}
        {% if types.cpp[param.type] == "std::string" %}{{ self::convert_arg(param=param) }}.c_str(){% else %}{{ self::convert_arg(param=param) }}{% endif %}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro func_impl(func, is_method=false, class=false, indent="") -%}
    {{ indent }}{%- if func.type == "String" -%}uint32_t turing_size = {% elif func.type in api.opaque_classes %}{{ types.cpp["op*"] }} turing_result = {% elif func.type == "void" or func.type == "self" %}{% else %}return {% endif -%}
    {{ func.from }}(
        {{- self::convert_args(params=func.params, is_method=is_method, class=class) -}}
    );{% if func.type == "self" %}
    return this;
    {%- elif func.type == "String" %}
    {{ indent }}if (turing_size == 0) {
    {{ indent }}    return "";
    {{ indent }}}
    {{ indent }}std::string turing_buf(turing_size, '\0');
    {{ indent }}_host_strcpy(const_cast<char*>(turing_buf.data()), turing_size);
    {{ indent }}return turing_buf;
    {% elif func.type in api.opaque_classes %}
    {{ indent }}return {{ func.type | case(style="pascal") }}(turing_result);
    {% endif %}
{%- endmacro -%}

{%- macro func_impls(funcs, is_method=false, class=false, indent="") -%}
{%- for func in funcs %}
{% if func.type == "self" %}{{ class.name | case(style="pascal") }}*{% else %}{{ types.cpp[func.type] }}{% endif %} {% if class %}{{ class.name | case(style="pascal") }}::{% endif %}{{ func.name | case(style="camel") }}(
    {{- self::cpp_params(params=func.params, is_method=is_method) -}}
) {
    {{ indent }}{{ self::func_impl(func=func, is_method=is_method, class=class, indent=indent) }}
{{ indent -}} }
{%- endfor %}
{%- endmacro -%}


///// Generated C++ API /////
#include "{{ api.name }}.hpp"
#include "{{ api.name }}_wasm.h"
#include <string>

namespace {{ api.name }}_cpp {

uint64_t _{{ api.name }}_semver() {
    return ((uint64_t){{ api.semver.major }} << 16) | ((uint64_t){{ api.semver.minor }} << 8) | (uint64_t){{ api.semver.patch }};
}

//// Functions ////
{{ self::func_impls(funcs=api.functions) }}
//// Classes ////
{%- for class in api.classes %}

// class {{ class.name | case(style="pascal") }}
{% if class.is_opaque -%}
{{ class.name | case(style="pascal") }}::{{ class.name | case(style="pascal") }}({{ types.cpp["op*"] }} ptr) : opaqu(ptr) {}
{% endif -%}
{{ self::func_impls(funcs=class.functions, class=class) }}
{{ self::func_impls(funcs=class.methods, is_method=true, class=class) }}
{%- endfor %}

} // namespace {{ api.name }}_cpp
