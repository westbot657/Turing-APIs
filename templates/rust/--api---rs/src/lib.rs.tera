
{% macro converter(param, indent="") -%}
    {%- if param.type == "&str" %}
    {{ indent }}let turing_handle_{{ param.name | case(style="snake") }} = CString::new({{ param.name | case(style="snake") }}).unwrap();
    {{ indent }}let {{ param.name | case(style="snake") }} = turing_handle_{{ param.name | case(style="snake") }}.as_ptr();
    {%- elif param.type in api.glam_types %}
    {{ indent }}let {{ param.name | case(style="snake") }} = alg::enqueue_{{ param.type | case(style="lower") }}({{ param.name | case(style="snake") }});
    {%- endif -%}
{%- endmacro -%}

{%- macro convert_arg(param) -%}
    {{ param.name | case(style="snake") }}
{%- endmacro -%}

{%- macro c_arg(type) -%}
    {%- if type == "&str" %}*const c_char{% elif type in api.glam_types %}u32{% else %}{{ types.rs[type] }}{% endif -%}
{%- endmacro -%}

{%- macro c_params(params, is_method=false, class=false) -%}
    {%- if is_method -%}
    opaqu: {% if class.is_opaque %}{{ types.rs["op*"] }}{% else %}{{ class.name | case(style="pascal") }}{% endif %}
    {%- for param in params -%}
    , {{ param.name | case(style="snake") }}: {{ self::c_arg(type=param.type) }}
    {%- endfor -%}
    {%- else -%}
    {%- for param in params -%}
    {{ param.name | case(style="snake") }}: {{ self::c_arg(type=param.type) }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro rs_params(params, is_method=false, class=false) -%}
    {%- if is_method -%}
    &self
    {%- for param in params -%}
    , {{ param.name | case(style="snake") }}: {{ types.rs[param.type] }}
    {%- endfor -%}
    {%- else -%}
    {%- for param in params -%}
    {{ param.name | case(style="snake") }}: {{ types.rs[param.type] }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
    {%- endif -%}

{%- endmacro -%}

{%- macro c_ret(type) -%}
    {%- if type == "void" %}{% elif type == "String" or type in api.glam_types %} -> u32{% elif type in api.opaque_classes %} -> u64{% else %} -> {{ types.rs[type] }}{% endif %}
{%- endmacro -%}

{%- macro convert_args(params, is_method=false, class=false) -%}
    {%- if is_method -%}
        self{% if class.is_opaque %}.opaqu{% endif %}
        {%- for param in params -%}
        , {{ self::convert_arg(param=param) }}
        {%- endfor -%}
    {%- else -%}
        {%- for param in params -%}
        {{ self::convert_arg(param=param) }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro func_impl(func, is_method=false, class=false, indent="") -%}
    {%- for param in func.params -%}
    {{- self::converter(param=param, indent=indent) -}}
    {%- endfor %}
    {{ indent }}{%- if func.type == "String" or func.type in api.opaque_classes -%}let turing_result = {% endif -%}
    unsafe { {{ func.from }}(
        {{- self::convert_args(params=func.params, is_method=is_method, class=class) -}}
    ) }{% if func.type == "self" %};
    {{ indent }}self{% elif func.type == "String" %};
    {{ indent }}let mut turing_str: Vec<u8> = vec![0; turing_result as usize];
    {{ indent }}unsafe { _host_strcpy(turing_str.as_mut_ptr() as *mut c_char, turing_result) };
    {{ indent }}let turing_str = unsafe { CStr::from_ptr(turing_str.as_ptr() as *const c_char) };
    {{ indent }}turing_str.to_string_lossy().into_owned()
    {%- elif func.type in api.glam_types %};
    {{ indent }}alg::dequeue_{{ func.type | case(style="lower") }}()
    {%- elif func.type in api.opaque_classes %};
    {{ indent }}{{ func.type | case(style="pascal") }} { opaqu: turing_result }
    {%- endif %}

{%- endmacro -%}

{%- macro ffi_funcs(funcs, is_method=false, class=false) -%}
    {%- for func in funcs %}
    fn {{ func.from }}({{ self::c_params(params=func.params, is_method=is_method, class=class) }}){{ self::c_ret(type=func.type) }};
    {%- endfor -%}
{%- endmacro -%}

{%- macro func_impls(funcs, is_method=false, class=false, indent="") -%}
{%- for func in funcs %}
{% if func.doc %}{{ indent }}{{ docs(doc=func.doc, d="/// ") }}{% endif %}
{{ indent }}pub fn {{ func.name | case(style="snake") }}(
    {{- self::rs_params(params=func.params, is_method=is_method, class=class) -}}
){%- if func.type == "self" %} -> &Self{%- elif func.type != "void" %} -> {{ types.rs[func.type] }}{% endif %} {
{{- self::func_impl(func=func, is_method=is_method, class=class, indent=indent) }}
{{ indent -}} }
{%- endfor %}
{%- endmacro -%}

///// Generated Rust API /////
use std::ffi::{CString, CStr, c_char, c_void};


mod alg {
    use crate::*;

    #[cfg(feature = "glam")]
    use glam::{Vec2, Vec3, Vec4, Quat, Mat4};

    #[cfg(feature = "nalgebra")]
    use nalgebra::{Vector2, Vector3, Vector4, Quaternion, Matrix4};

    #[cfg(feature = "nalgebra")]
    pub type Vec2 = Vector2<f32>;
    #[cfg(feature = "nalgebra")]
    pub type Vec3 = Vector3<f32>;
    #[cfg(feature = "nalgebra")]
    pub type Vec4 = Vector4<f32>;
    #[cfg(feature = "nalgebra")]
    pub type Quat = Quaternion<f32>;
    #[cfg(feature = "nalgebra")]
    pub type Mat4 = Matrix4<f32>;

    pub fn dequeue_vec2() -> Vec2 {
        let x = unsafe { _host_f32_dequeue() };
        let y = unsafe { _host_f32_dequeue() };
        Vec2::new(x, y)
    }

    pub fn enqueue_vec2(v: Vec2) -> u32 {
        unsafe {
            _host_f32_enqueue(v.x);
            _host_f32_enqueue(v.y);
        }
        2
    }

    pub fn dequeue_vec3() -> Vec3 {
        let x = unsafe { _host_f32_dequeue() };
        let y = unsafe { _host_f32_dequeue() };
        let z = unsafe { _host_f32_dequeue() };
        Vec3::new(x, y, z)
    }

    pub fn enqueue_vec3(v: Vec3) -> u32 {
        unsafe {
            _host_f32_enqueue(v.x);
            _host_f32_enqueue(v.y);
            _host_f32_enqueue(v.z);
        }
        3
    }

    pub fn dequeue_vec4() -> Vec4 {
        let x = unsafe { _host_f32_dequeue() };
        let y = unsafe { _host_f32_dequeue() };
        let z = unsafe { _host_f32_dequeue() };
        let w = unsafe { _host_f32_dequeue() };
        Vec4::new(x, y, z, w)
    }

    pub fn enqueue_vec4(v: Vec4) -> u32 {
        unsafe {
            _host_f32_enqueue(v.x);
            _host_f32_enqueue(v.y);
            _host_f32_enqueue(v.z);
            _host_f32_enqueue(v.w);
        }
        4
    }

    pub fn dequeue_quat() -> Quat {
        let x = unsafe { _host_f32_dequeue() };
        let y = unsafe { _host_f32_dequeue() };
        let z = unsafe { _host_f32_dequeue() };
        let w = unsafe { _host_f32_dequeue() };
        #[cfg(feature = "nalgebra")]
        return Quat::new(x, y, z, w);
        #[cfg(feature = "glam")]
        Quat::from_xyzw(x, y, z, w)
    }

    pub fn enqueue_quat(v: Quat) -> u32 {
        unsafe {
            #[cfg(feature = "nalgebra")]
            let v = v.coords;
            _host_f32_enqueue(v.x);
            _host_f32_enqueue(v.y);
            _host_f32_enqueue(v.z);
            _host_f32_enqueue(v.w);
        }
        4
    }

    pub fn dequeue_mat4() -> Mat4 {
        let mut arr = [0f32; 16];
        for i in 0..16 {
            arr[i] = unsafe { _host_f32_dequeue() };
        }
        #[cfg(feature = "nalgebra")]
        return Mat4::from_column_slice(&arr);
        #[cfg(feature = "glam")]
        Mat4::from_cols_array(&arr)
    }

    pub fn enqueue_mat4(m: Mat4) -> u32 {
        #[cfg(feature = "nalgebra")]
        let slice = m.as_slice();
        #[cfg(feature = "glam")]
        let slice = m.to_cols_array();

        for v in slice {
            #[cfg(feature = "nalgebra")]
            let v = *v;
            unsafe { _host_f32_enqueue(v) };
        }

        16
    }

}

//// Wasm Bindings ////
unsafe extern "C" {
    {% if api.name == "turing_api" %}fn _host_strcpy(location: *const c_char, size: {{ types.rs["u32"] }});
    fn _host_f32_enqueue(f: {{ types.rs["f32"] }});
    fn _host_f32_dequeue() -> {{ types.rs["f32"] }};{% endif %}
    {{- self::ffi_funcs(funcs=api.functions) }}
    {%- for class in api.classes -%}
    {{- self::ffi_funcs(funcs=class.functions, class=class) }}
    {{- self::ffi_funcs(funcs=class.methods, is_method=true, class=class) }}
    {%- endfor %}
}

#[unsafe(no_mangle)]
extern "C" fn _{{ api.name }}_semver() -> u64 {
    ({{ api.semver.major }}u64 << 32) | ({{ api.semver.minor }}u64 << 16) | {{ api.semver.patch }}u64
}
pub const {{ api.name | case(style="upper_snake") }}_VERSION: &str = "{{ api.version }}";

//// Functions ////
{{ self::func_impls(funcs=api.functions) }}


//// Classes ////
{%- for class in api.classes %}
{% if class.doc %}{{ docs(doc=class.doc, d="/// ") }}{% endif %}
pub struct {{ class.name | case(style="pascal") }} {
    {%- for var in class.variables %}
    {{ var.name }}: {{ types.rs[var.type] }},
    {%- endfor %}
}
impl {{ class.name | case(style="pascal") }} {
    {{- self::func_impls(funcs=class.functions, class=class, indent="    ") }}
    {{- self::func_impls(funcs=class.methods, is_method=true, class=class, indent="    ") }}
}
{% endfor %}


