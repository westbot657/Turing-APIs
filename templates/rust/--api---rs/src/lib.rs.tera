
{% macro converter(param, indent="") -%}
    {%- if param.type == "&str" %}
    {{ indent }}let turing_handle_{{ param.name | case(style="snake") }} = CString::new({{ param.name | case(style="snake") }}).unwrap();
    {{ indent }}let {{ param.name | case(style="snake") }} = turing_handle_{{ param.name | case(style="snake") }}.as_ptr();
    {%- endif -%}
{%- endmacro -%}

{%- macro convert_arg(param) -%}
    {{ param.name | case(style="snake") }}
{%- endmacro -%}

{%- macro c_arg(type) -%}
    {%- if type == "&str" %}*const c_char{% else %}{{ types.rs[type] }}{% endif -%}
{%- endmacro -%}

{%- macro c_params(params, is_method=false, class=false) -%}
    {%- if is_method -%}
    opaqu: {% if class.is_opaque %}{{ types.rs["op*"] }}{% else %}{{ class.name | case(style="pascal") }}{% endif %}
    {%- for param in params -%}
    , {{ param.name | case(style="snake") }}: {{ self::c_arg(type=param.type) }}
    {%- endfor -%}
    {%- else -%}
    {%- for param in params -%}
    {{ param.name | case(style="snake") }}: {{ self::c_arg(type=param.type) }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro rs_params(params, is_method=false, class=false) -%}
    {%- if is_method -%}
    &self
    {%- for param in params -%}
    , {{ param.name | case(style="snake") }}: {{ types.rs[param.type] }}
    {%- endfor -%}
    {%- else -%}
    {%- for param in params -%}
    {{ param.name | case(style="snake") }}: {{ types.rs[param.type] }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
    {%- endif -%}

{%- endmacro -%}

{%- macro c_ret(type) -%}
    {%- if type == "void" %}{% elif type == "String" %} -> u32{% else %} -> {{ types.rs[type] }}{% endif %}
{%- endmacro -%}

{%- macro convert_args(params, is_method=false, class=false) -%}
    {%- if is_method -%}
        self{% if class.is_opaque %}.opaqu{% endif %}
        {%- for param in params -%}
        , {{ self::convert_arg(param=param) }}
        {%- endfor -%}
    {%- else -%}
        {%- for param in params -%}
        {{ self::convert_arg(param=param) }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro func_impl(func, is_method=false, class=false, indent="") -%}
    {%- for param in func.params -%}
    {{- self::converter(param=param, indent=indent) -}}
    {%- endfor %}
    {{ indent }}{%- if func.type == "String" or func.type in api.opaque_classes -%}let turing_result = {% endif -%}
    unsafe { {{ func.from }}(
        {{- self::convert_args(params=func.params, is_method=is_method, class=class) -}}
    ) }{% if func.type == "self" %};
    {{ indent }}self{% elif func.type == "String" %};
    {{ indent }}let mut turing_str: Vec<u8> = vec![0; turing_result as usize];
    {{ indent }}unsafe { _host_strcpy(turing_str.as_mut_ptr() as *mut c_char, turing_result) };
    {{ indent }}let turing_str = unsafe { CStr::from_ptr(turing_str.as_ptr() as *const c_char) };
    {{ indent }}turing_str.to_string_lossy().into_owned()
    {%- elif func.type in api.opaque_classes %};
    {{ indent }}{{ func.type | case(style="pascal") }} { opaqu: turing_result }
    {%- endif %}

{%- endmacro -%}

{%- macro ffi_funcs(funcs, is_method=false, class=false) -%}
    {%- for func in funcs %}
    fn {{ func.from }}({{ self::c_params(params=func.params, is_method=is_method, class=class) }}){{ self::c_ret(type=func.type) }};
    {%- endfor -%}
{%- endmacro -%}

{%- macro func_impls(funcs, is_method=false, class=false, indent="") -%}
{%- for func in funcs %}
{% if func.doc %}{{ indent }}/// {{ func.doc }}{% endif %}
{{ indent }}pub fn {{ func.name | case(style="snake") }}(
    {{- self::rs_params(params=func.params, is_method=is_method, class=class) -}}
){%- if func.type == "self" %} -> &Self{%- elif func.type != "void" %} -> {{ types.rs[func.type] }}{% endif %} {
{{- self::func_impl(func=func, is_method=is_method, class=class, indent=indent) }}
{{ indent -}} }
{%- endfor %}
{%- endmacro -%}

///// Generated Rust API /////
use std::ffi::{CString, CStr, c_char, c_void};


//// Wasm Bindings ////
unsafe extern "C" {
    {% if api.name == "turing_api" %}fn _host_strcpy(location: *const c_char, size: {{ types.rs["u32"] }});
    fn _host_f32_enqueue(f: {{ types.rs["f32"] }});
    fn _host_f32_dequeue() -> {{ types.rs["f32"] }};{% endif %}
    {{- self::ffi_funcs(funcs=api.functions) }}
    {%- for class in api.classes -%}
    {{- self::ffi_funcs(funcs=class.functions, class=class) }}
    {{- self::ffi_funcs(funcs=class.methods, is_method=true, class=class) }}
    {%- endfor %}
}

#[unsafe(no_mangle)]
extern "C" fn _{{ api.name }}_semver() -> u64 {
    ({{ api.semver.major }}u64 << 16) | ({{ api.semver.minor }}u64 << 8) | {{ api.semver.patch }}u64
}
pub const {{ api.name | case(style="upper_snake") }}_VERSION: &str = "{{ api.version }}";

//// Functions ////
{{ self::func_impls(funcs=api.functions) }}


//// Classes ////
{%- for class in api.classes %}
{% if class.doc %}/// {{ class.doc }}{% endif %}
pub struct {{ class.name | case(style="pascal") }} {
    {%- for var in class.variables %}
    {{ var.name }}: {{ types.rs[var.type] }},
    {%- endfor %}
}
impl {{ class.name | case(style="pascal") }} {
    {{- self::func_impls(funcs=class.functions, class=class, indent="    ") }}
    {{- self::func_impls(funcs=class.methods, is_method=true, class=class, indent="    ") }}
}
{% endfor %}


