#api core
#version 0.1.0


// This file was generated by Turing.rs, it is used to generate API bindings for all supported languages.
// Please DO NOT modify this file unless you know what you are doing.

:GameObject [opaque]:
:Transform [opaque]:
:TuringScriptManager [opaque]:
:Object [opaque]:
:List`1 [opaque]:
:List [opaque]:
:List1 [opaque]:

:GcHelper [opaque] :
wasm_garbage_collect() -> void : _gc_helper__wasm_garbage_collect
::create() -> GcHelper : _gc_helper__create
dispose() -> void : _gc_helper__dispose
wasm_free_handle(obj: Object) -> void : _gc_helper__wasm_free_handle
:TuringGameObjectManager [opaque] :
create_object(name: &str) -> TuringerGameObject : _turing_game_object_manager__create_object
destroy_object(gameObject: TuringerGameObject) -> void : _turing_game_object_manager__destroy_object
::find(name: &str) -> GameObject : _turing_game_object_manager__find
_turing_script_manager_get() -> TuringGameObjectManager : _turing_game_object_manager___turing_script_manager_get
instance_get() -> TuringGameObjectManager : _turing_game_object_manager__instance_get
_game_objects_get() -> TuringGameObjectManager : _turing_game_object_manager___game_objects_get
_turing_game_object_factory_get() -> TuringGameObjectManager : _turing_game_object_manager___turing_game_object_factory_get
::set_instance(value: TuringGameObjectManager) -> void : _turing_game_object_manager__set_instance
::get_instance() -> TuringGameObjectManager : _turing_game_object_manager__get_instance
:NoteManager:
::add_color_note(beat: f32, line: i32, layer: i32, color: i32, cutDirection: i32, customData: CustomData) -> void : _note_manager__add_color_note
::add_obstacle(beat: f32, duration: f32, line: i32, layer: i32, width: i32, height: i32, customData: CustomData) -> void : _note_manager__add_obstacle
::time_to_beat(time: f32) -> f32 : _note_manager__time_to_beat
::add_bomb_note(beat: f32, line: i32, layer: i32, customData: CustomData) -> void : _note_manager__add_bomb_note
:Log:
::debug(msg: &str) -> void : _log__debug
::critical(msg: &str) -> void : _log__critical
::warn(msg: &str) -> void : _log__warn
::info(msg: &str) -> void : _log__info
:TuringerGameObject [opaque] :
get_transform() -> Transform : _turinger_game_object__get_transform
transform_get() -> TuringerGameObject : _turinger_game_object__transform_get
get_turing_script_manager() -> TuringScriptManager : _turinger_game_object__get_turing_script_manager
get_game_object() -> GameObject : _turinger_game_object__get_game_object
game_object_get() -> TuringerGameObject : _turinger_game_object__game_object_get
_manager_get() -> TuringerGameObject : _turinger_game_object___manager_get
:CustomData [opaque]:
::create() -> CustomData : _custom_data__create
::list_create() -> List`1 : _custom_data__list_create
::set_custom_data_list(customData: CustomData, key: &str, value: List1) -> void : _custom_data__set_custom_data_list
::set_string(customData: CustomData, key: &str, value: &str) -> void : _custom_data__set_string
::set_float(customData: CustomData, key: &str, value: f32) -> void : _custom_data__set_float
::list_add_bool(list: List1, value: bool) -> void : _custom_data__list_add_bool
::list_add_int(list: List1, value: i32) -> void : _custom_data__list_add_int
::set_bool(customData: CustomData, key: &str, value: bool) -> void : _custom_data__set_bool
::set_custom_data(customData: CustomData, key: &str, value: CustomData) -> void : _custom_data__set_custom_data
::list_add_custom_data_list(list: List1, value: List1) -> void : _custom_data__list_add_custom_data_list
::list_add_float(list: List1, value: f32) -> void : _custom_data__list_add_float
::list_add_string(list: List1, value: &str) -> void : _custom_data__list_add_string
::set_int(customData: CustomData, key: &str, value: i32) -> void : _custom_data__set_int
::list_add_custom_data(list: List1, value: CustomData) -> void : _custom_data__list_add_custom_data
:Xr [opaque] :
::get_device_thumbstick(nodeInt: i32) -> Vec2 : _xr__get_device_thumbstick
::get_device_tracking_state(nodeInt: i32) -> i32 : _xr__get_device_tracking_state
::send_haptic_impulse(nodeInt: i32, amplitude: f32, duration: f32) -> void : _xr__send_haptic_impulse
::stop_haptics(nodeInt: i32) -> void : _xr__stop_haptics
::get_device_name(nodeInt: i32) -> String : _xr__get_device_name
::is_device_valid(nodeInt: i32) -> bool : _xr__is_device_valid
::get_device_battery_level(nodeInt: i32) -> f32 : _xr__get_device_battery_level
::get_device_trigger_value(nodeInt: i32) -> f32 : _xr__get_device_trigger_value
_manager_get() -> Xr : _xr___manager_get
::get_device_touchpad(nodeInt: i32) -> Vec2 : _xr__get_device_touchpad
::get_device_secondary_button_state(nodeInt: i32) -> bool : _xr__get_device_secondary_button_state
::get_device_grip_value(nodeInt: i32) -> f32 : _xr__get_device_grip_value
::get_device_primary_button_state(nodeInt: i32) -> bool : _xr__get_device_primary_button_state
