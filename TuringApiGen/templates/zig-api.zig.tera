
///// Generated Zig API /////
const std = @import("std");
const types = @import("types.zig");

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const allocator = gpa.allocator();

extern "C" fn _host_strcpy(location: [*]u8, size: u32) void;

//// Wasm Bindings ////
{% for func in api.functions -%}
{%- if func.from is defined and func.from -%}
extern "C" fn {{ func.from }}(
    {%- for param in func.params -%}
    {{ param.name | case(style="snake") }}: {% if param.type == "&str" %}[*:0]const u8{% elif param.type == "CString" %}[*:0]const u8{% else %}{{ types.zig[param.type] }}{% endif %}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
) {% if func.type == "void" %}void{% elif func.type == "String" %}u32{% else %}{{ types.zig[func.type] }}{% endif %};
{% endif -%}
{%- endfor %}

{% for class in api.classes -%}
{%- for func in class.functions -%}
{%- if func.from is defined and func.from -%}
extern "C" fn {{ func.from }}(
    {%- for param in func.params -%}
    {{ param.name | case(style="snake") }}: {% if param.type == "&str" %}[*:0]const u8{% elif param.type == "CString" %}[*:0]const u8{% else %}{{ types.zig[param.type] }}{% endif %}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
) {% if func.type == "void" %}void{% elif func.type == "String" %}u32{% else %}{{ types.zig[func.type] }}{% endif %};
{% endif -%}
{%- endfor -%}
{%- for func in class.methods -%}
{% if func.from is defined and func.from %}
extern "C" fn {{ func.from }}(opaqu: *const anyopaque
    {%- for param in func.params -%}
    , {{ param.name | case(style="snake") }}: {% if param.type == "&str" %}[*:0]const u8{% elif param.type == "CString" %}[*:0]const u8{% else %}{{ types.zig[param.type] }}{% endif %}
    {%- endfor -%}
) {% if func.type == "void" %}void{% elif func.type == "String" %}u32{% else %}{{ types.zig[func.type] }}{% endif %};
{% endif %}
{%- endfor -%}
{%- endfor %}

//// Functions ////
{% for func in api.functions %}
{%- if func.from is defined and func.from %}
pub fn {{ func.name | case(style="camel") }}(
    {%- for param in func.params -%}
    {{ param.name | case(style="snake") }}: {{ types.zig[param.type] }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
)
{%- if func.type == "String" or func.type == "void" %} !{% if func.type == "void" %}void{% else %}{{ types.zig[func.type] }}{% endif %} {% else %} !{{ types.zig[func.type] }} {% endif -%}
{
    {%- for param in func.params %}
    {%- if param.type == "&str" %}
    const {{ param.name | case(style="snake") }}_cstr = try allocator.dupeZ(u8, {{ param.name | case(style="snake") }});
    defer allocator.free({{ param.name | case(style="snake") }}_cstr);
    {%- endif -%}
    {%- endfor %}
    {% if func.type != "void" -%}const _res = {% endif -%}
    {{ func.from }}(
        {%- for param in func.params -%}
        {%- if param.type == "&str" %}{{ param.name | case(style="snake") }}_cstr{% else %}{{ param.name | case(style="snake") }}{% endif %}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    );
    {% if func.type == "void" -%}
    return;
    {%- elif func.type == "String" -%}
    const str = try allocator.alloc(u8, _res);
    _host_strcpy(str.ptr, _res);
    return str;
    {%- elif func.type in api.opaque_classes -%}
    return {{ func.type | case(style="pascal") }}{
        .opaqu = _res,
    };
    {%- else -%}
    return _res;
    {%- endif %}
}
{%- else %}
// FIXME: No wasm binding defined for {{ func.name | case(style="snake") }}
{%- endif %}

{%- endfor %}

//// Classes ////
{%- for class in api.classes %}

pub const {{ class.name | case(style="pascal") }} = struct {
{%- for var in class.variables %}
    {{ var.name | case(style="snake") }}: {{ types.zig[var.type] }},
{%- else %}
    {% if class.is_opaque -%}
    opaqu: *const anyopaque,
    {%- else -%}
    // No fields
    {%- endif %}
{% endfor -%}

    {%- for func in class.functions %}
    {%- if func.from is defined and func.from %}
    pub fn {{ func.name | case(style="camel") }}(
        {%- for param in func.params -%}
        {{ param.name | case(style="snake") }}: {{ types.zig[param.type] }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    )
    {%- if func.type == "String" or func.type == "void" %} !{% if func.type == "void" %}void{% else %}{{ types.zig[func.type] }}{% endif %} {% else %} !{{ types.zig[func.type] }} {% endif -%}
    {
        {%- for param in func.params %}
        {%- if param.type == "&str" %}
        const {{ param.name | case(style="snake") }}_cstr = try allocator.dupeZ(u8, {{ param.name | case(style="snake") }});
        defer allocator.free({{ param.name | case(style="snake") }}_cstr);
        {%- endif -%}
        {%- endfor %}
        {% if func.type != "void" -%}const _res = {% endif -%}
        {{ func.from }}(
            {%- for param in func.params -%}
            {%- if param.type == "&str" %}{{ param.name | case(style="snake") }}_cstr{% else %}{{ param.name | case(style="snake") }}{% endif %}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        );
        {% if func.type == "void" -%}
        return;
        {%- elif func.type == "String" -%}
        const str = try allocator.alloc(u8, _res);
        _host_strcpy(str.ptr, _res);
        return str;
        {%- elif func.type in api.opaque_classes -%}
        return {{ func.type | case(style="pascal") }}{
            .opaqu = _res,
        };
        {%- else -%}
        return _res;
        {%- endif %}
    }
    {%- else -%}
    // FIXME: No wasm binding defined for {{ func.name | case(style="snake") }}
    {%- endif -%}
    {%- endfor -%}

    {%- for func in class.methods %}
    {% if func.from is defined and func.from -%}
    pub fn {{ func.name | case(style="camel") }}(self: {{ class.name | case(style="pascal") }}
    {%- for param in func.params -%}
    , {{ param.name | case(style="snake") }}: {{ types.zig[param.type] }}
    {%- endfor -%}
    )
    {%- if func.type == "String" or func.type == "void" %} !{% if func.type == "void" %}void{% else %}{{ types.zig[func.type] }}{% endif %} {% else %} !{{ types.zig[func.type] }} {% endif -%}
    {
        {%- for param in func.params %}
        {%- if param.type == "&str" %}
        const {{ param.name | case(style="snake") }}_cstr = try allocator.dupeZ(u8, {{ param.name | case(style="snake") }});
        defer allocator.free({{ param.name | case(style="snake") }}_cstr);
        {%- endif -%}
        {%- endfor %}
        {% if func.type != "void" -%}const _res = {% endif -%}
        {{ func.from }}({% if class.is_opaque %}self.opaqu{% else %}&self{% endif %}
            {%- for param in func.params -%}
            , {%- if param.type == "&str" %}{{ param.name | case(style="snake") }}_cstr{% else %}{{ param.name | case(style="snake") }}{% endif %}
            {%- endfor -%}
        );
        {% if func.type == "void" -%}
        return;
        {%- elif func.type == "String" -%}
        const str = try allocator.alloc(u8, _res);
        _host_strcpy(str.ptr, _res);
        return str;
        {%- elif func.type in api.opaque_classes -%}
        return {{ func.type | case(style="pascal") }}{
            .opaqu = _res,
        };
        {%- else -%}
        return _res;
        {%- endif %}
    }
    {%- else -%}
    // FIXME: No wasm binding defined for {{ func.name | case(style="snake") }}
    {%- endif -%}
    {%- endfor %}
};

{%- endfor %}



