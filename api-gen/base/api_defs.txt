// Hi, indentation in this file is very important in making life easier (simpler parsing)
// please don't modify the indentation (and only 4-space increments allowed)

#struct-defs


class Color {
    ptr: i32

    fn get_r(&self) -> f32 #mdef.pass_ptr_attr(self)

}

#macro $1
#pattern # ColorNote # BombNote # Arc # Wall # ChainHeadNote # ChainLinkNote # ChainNote
#macro apply
class $1 {
    ptr: i32

    fn get_color(&self) -> Color #mdef.pass_ptr_attr(self)

}
#macro end

class Log {

    static fn info(msg: str) -> void #mdef.log(info)
    static fn warn(msg: str) -> void #mdef.log(warn)
    static fn critical(msg: str) -> void #mdef.log(error)
    static fn debug(msg: str) -> void #mdef.log(debug)

}

class Beatmap {

    #macro $1 $2
    #pattern # color_note ColorNote # bomb_note BombNote # arc Arc # wall Wall # chain_head_note ChainHeadNote # chain_link_note ChainLinkNote # chain_note ChainNote
    #macro apply

    static fn add_$1($1: $2) -> void #mdef.pass_ptr_attr($1)
    static fn remove_$1($1: $2) -> void #mdef.pass_ptr_attr($1)

    #macro end

}




#code-defs

#pass_ptr_attr($1) {
    #C, #C++, #zig, #ts {
        ~($1.ptr);
    }
    #lua {
        ~($1.ptr)
    }
}

#str_to_ptr {
    #C, #lua {
        ~(msg)
    }
    #C++ {
        ~(msg.c_str())
    }
    #zig {
        ~(@ptrCast([*]const u8, msg.ptr))
    }
    #ts {
        ~(changetype<usize>(String.UTF8.encode(msg)))
    }
}

#log($1) {
    #C, #C++ {
        char* s = concat_strings("$1", msg);
        _log(s);
        free(s);
    }
    #lua {
        _log(string.format("$1%s", msg))
    }
    #zig {
        var gpa = std.heap.GeneralPurposeAllocator(.{}){};
        const allocator = gpa.allocator();
        const s = try concat_strings(allocator, "$1", msg);
        defer allocator.free(s);
        _log(@ptrCast(msg.ptr));
    }
    #ts {
        _log(<i32>changetype<usize>(String.UTF8.encode("$1" + msg)));
    }
}

#constructor_beat($1) {
    #C {
        $1 inst;
        inst.ptr = ~(beat);
        return inst;
    }
    #C++ {
        $1 inst = $1 {};
        inst.ptr = ~(beat);
        return inst;
    }
    #zig {
        return .{ .ptr = ~(beat) };
    }
    #lua {
        local ptr: int32 = ~(beat)
        local note: $1 = { ptr = ptr }
        return note
    }
    #ts {
        let ptr = ~(beat);
        return new $1(ptr);
    }
}


#static-defs

#C {

    char* concat_strings(const char* str1, const char* str2) {
        int len1 = strlen(str1);
        int len2 = strlen(str2);
        char* result = malloc(len1 + len2 + 1); // +1 for null terminator
        
        if (result) {
            strcpy(result, str1);
            strcat(result, str2);
        }
        
        return result;
    }

}

#C++ {
    char* concat_strings(const char* str1, const char* str2) {
        int len1 = strlen(str1);
        int len2 = strlen(str2);
        char* result = (char*) malloc(len1 + len2 + 1); // +1 for null terminator
        
        if (result) {
            strcpy(result, str1);
            strcat(result, str2);
        }
        
        return result;
    }
}

#zig {

    pub fn concat_strings(allocator: std.mem.Allocator, str1: []const u8, str2: []const u8) ![]u8 {
        const new_len = str1.len + str2.len;
        const result = try allocator.alloc(u8, new_len);
        std.mem.copy(u8, result[0..str1.len], str1);
        std.mem.copy(u8, result[str1.len..], str2);
        return result;
    }

}

#ts {

    export function toCString(str: string): u32 {
        return <u32>changetype<usize>(String.UTF8.encode(str, true));
    }

    export function readCString(ptr: u32): void {
        const str = String.UTF8.decodeUnsafe(ptr, u32.MAX_VALUE, true); // true = null-terminated
        console.log(str);
    }

}

#lua {

}


